/* -*- C++ -*- */
/** @mainpage TREX A Teleo-Reactive Executive 


This is the documentation of TREX codename
<a href="http://www.youtube.com/watch?v=RM9o4VnfHJU&feature=channel_page">barreleye</a>. 
This version is the first TREX version that do not rely on Europa for
its core functionalities as a result one can use TREX with which ever 
planner he wants - as long as this one can hanlde properly the goal 
representation expected by TREX.


@section install Installing TREX

@subsection install-requirement Third party requirements

TREX uses third party utilities and libraries. Here's sa list of them
: 
@li @b jam (http://www.perforce.com/jam/jam.html) This is a @c make
replacement utility used to compile TREX. The version used during
development was jam 2.5
@li @b rapidXML (http://rapidxml.sourceforge.net/) This is used for
configuration parsing.  TREX used to rely on TinyXML version embedded
in Europa but keeping this would have been annoying as this version
was part of Europa and keeping the ability to connect to Europa while
using a version of TinyXML which is not necessarily the Europa one
would have been tricky. On top of that rapidxml is really lightweight
(only templates defined in C++ headers) and very fast (performance
close to strlen). The version used -- and provided -- for this package
is 1.13.
@li @b boost (http://www.boost.org) This library is widely used for
basic utilities and compatibilty with the TR1 C++0x standard. As we use
flyweight the earliest version to be used is 1.38.0 (we tested it with
boost 1.40.0). We also use the Boost Graph Library but should support version 
1.36.0 and above according to its latest documentation

Others utilies are of interrest but not necessary to use TREX:
@li @e doxygen (http://www.doxygen.org/) This utility is needed only
if you want  to generate this documentation.
@li @e graphviz (http://www.graphviz.org/) Recommended for
documentation but it may also be used for plan visualization by
showing tokens and their relations as a graph.

@note rapidxml is bundled into TREX. Nothing as been changed in this
libray and if one prefers to use another version of this library he
justs need to define the environment variable @c TINY_XML_ROOT with
the directory where this one is before compiling TREX.

@subsection install-env Set your environment

The @c devConfig @c bash file loads all the variables needed to be
able to compile and execute TREX. If you are using bash you can edit
your @c ~/.profile (or @c ~/.bash_profile depending on your
configuration/platform). Considering that you have put TREX on the
directory @c @<trex-dir@> you can put the following lines : 
@code
path=`pwd` 
cd <trex-dir> 
source devConfig 
cd $path 
@endcode
@attention Under MacOS X you also need to define @c DYLD_BIND_AT_LAUNCH to
allow dynamic library loading on the fly. Indeed, this version of
TREX supports plugin allowing to define externally new reactors and 
components and MacOS X needs to be informed about that. To do so add
the following line in your @c ~/.profile :
@code
export DYLD_BIND_AT_LAUNCH=YES
@endcode

@subsection install-main TREX general structure 

@image html SWarchi.png "TREX Software architecture" width=10cm

This version of TREX is composed of multiples libraries and
components which are organized as follow:
@li <b> Main libraries: </b> They are also called @e module. All of
them are compiled into the @c lib directory. There's 4 of them
described more in detail in this document :
<ul>
<li> @c TREXutils : A set of classes that represent basic
functionallities that are used by TREX but are more based on 
generic programming paradigms and design patterns that could be
used for other programs.</li>
<li> @c TREXdomains : Definition of domains and variables as manipulated
by TREX for information exchange between reactors. A variabl is
defined by a name and a domain. A domain is a typed, possibly continuous,
set of possible values for this varaible. A domain cannot be empty and
can only be restricted.</li>
<li> @c TREXtransaction : This library define the reactors which is the
basic component that can be composed inside TREX. It defines also
Obsevations and Goals which are the data that can be exchanged between
reactors.</li>
<li> @c TREXagent : Defines the TREX agent. The agent is the main
entity that manages the loading and execution of the reactors as their
interaction.</li>
</ul>
@li <b> TREX commands: </b> A set of simple commands that can be used
to execute a TREX agent. They are compiled into the @c bin
directory. There's two generic commands that gives a simple
illustration on how one can create and manipulate an Agent :
<ul>
<li> @c amc : This program takes a configuration file as
argument. Provided that this file defines correctly an Agent it will
execute this agent until its end.</li>
<li> @c sim : This program takes similar argument as @c amc. The
difference here is that it provides a simple interface to run the
agent in an interactive way allowing to step through clock ticks.
</li>
</ul>
@li <b> TREX plug-ins: </b> These are optionnally compiled and the
source is usually located under @c extra/@<name@>. You can comile them
by calling @c jam @c @<name@>. The result will be put under @c extra
directory  as a dynamic library named @c TREX@<name@>.
@li <b> TREX documentation: </b> Generated from the source using @c
jam @c doc. It will be installed on the @c doc directory.
@li <b> TREX logs: </b> Usually generated under the @c log directory
after any run of a TREX agent.
@li <b> TREX utilities and scripts: </b> Under @c offboard. Provides a 
set of scripts and utilities to help the processing  of TREX logs.
@li <b> nightly build: </b> Under @c nightly,. Used to run nightly builds 
of the head.
@li <b> Configurations files </b> Usually under @c cfg. A set of configuration files that can be used to define new agents and/or reactors.

Compiling the core components (main libraries and commands) is done with the command @c jam. 

Compilation of the plug-ins is done using the command @c jam @<name@>

@section Running an example

So farthis version of TREX do not provide that much illustrations but at least a simple one exist with the lightswitch plug-in. To use it you first need to compile the @c sim utility and @c lightswitch plug-in :
@code 
~$ cd $TREX_HOME
TREX2$ jam sim
...found 243 target(s)...
...updating 27 target(s)...
[...]
Link bin/sim 
Chmod1 bin/sim 
...updated 27 target(s)...
TREX2$ jam lightswitch
...found 235 target(s)...
...updating 2 target(s)...
C++ extra/lightswitch/objects/LightSwitch.o 
SharedArchive plugin/libTREXlightswitch.dylib 
...updated 2 target(s)...
TREX2$
@endcode

After have compiled check that your @c $TREX_PATH contains both @c $TREX_HOME/cfg
and @c $TREX_HOME/plugin. For exampel in my configuration, where TREX is installed
on /Users/fpy/Coding/TREX2, I have:
@code 
TREX2$ echo $TREX_PATH
/Users/fpy/Coding/TREX2/cfg:/Users/fpy/Coding/TREX2/plugin
@endcode

You can now start the simulation but beforehand we are going to give a look at the configuration files on $TREX_HOME/cfg used for this short test. We are going to use 3 of them :
@li @c sample.cfg Is rthe mission config file
@li @c lighton.req and @c lightoff.req are fiules describing goals that one can post interactivelly through the sim interface

The content of @c sample.cfg should looks similar to this :
@code  
<Agent name="sample" finalTick="100" >
       <Plugin name="TREXlightswitch"/>
       <Light name="switch" latency="0" lookahead="1" state="1"/>
</Agent>
@endcode
The @c Agent tag declare the global agent with its @c name and @c finalTick both of them can be freely modified.

The @c Plugin tag indicates that this mission need to load the @c TREXlightswitch plug-in. Based on that @c sim will automatically look on local directory and @c TREX_PATH to locate this plug-in.

Finally @c Light declare a reactor which is implemented in @c TREXlightswitch. This one starts with a @c state of 1 which mean that its light is on. You can change it to 0 if you want to start with the light off.

@subsection start the @c sample mission

To satrt the sample mission you can do the following :
@code 
TREX2$ sim sample 
Options:
  Q :- quit
  N :- next tick
  G :- goto tick (e.g. g100)
  P :- post the goals from the attached file
       (e.g P goal.req)
  H :- print this help message
[sample:0]>
@endcode
The mission is loaded and the prompt indicate the name of the agent (sample) and
the current tick value 0. You can use commands to interact with the agent by advancing of one tick (N), go to a given tick in the future (G) or post a request described in a file (P)

you can also in an alternate terminal look on the activity of the agent redicrected
in @c $TREX_LOG_DIR/latest/TREX.log
@code 
~$ cd $TREX_LOG_DIR
log$ tail -F latest/TREX.log
[lightswitch] LightSwitch loaded.

@endcode
At this stage it indicate the lightsiwtch plug-in was successfully loaded. But as the mission you'll see other messages including new observations on timelines (ASSERT), requests, ...

Going back to the sim shell you can then uses the command to switch the lights on or off on your reactor. For example 
@code 
Options:
  Q :- quit
  N :- next tick
  G :- goto tick (e.g. g100)
  P :- post the goals from the attached file
       (e.g P goal.req)
  H :- print this help message
[sample:0]> n
[sample:1]> P lighton
Loading "/Users/fpy/Coding/TREX2/cfg/lighton.req"... done
Extracting goals:
 - light.Light.On
[sample:1]> n
[sample:2]> g10
[sample:10]> p lightoff
Loading "/Users/fpy/Coding/TREX2/cfg/lightoff.req"... done
Extracting goals:
 - light.Light.Off
[sample:10]> n
[sample:11]> g1000
Mission completed.
TREX2$
@endcode

@note The ticks are not in real-time in @c sim. This is related to the fact that
@c sim needs to be able to interrupt the clock and restart it. We plan to implement a
pseudo real-time clakc but most of the time the we use @c sim to replay a past mission (using a LogPlayer reactor which is not provided yet on this version) and as these can be long (hours) the fast sim clock is a better fit.

@note At this stage this is the only mission directly available on TREX. This is due to the fact that our effort was more focused on make TREX independent from Europa than implement a large set of reactors. The porting of other reactors (Log player, europa 2.1.1 based, latest europa based, ... ) are in the process and should be available soon.
*/





/** @defgroup core TREX core 
 * @brief Core components of TREX
 *
 * This module embeds all the components considered as the core of TREX.
 *
 * @author Conor McGann @& Frederic Py <fpy@mbari.org>
 */

/** @defgroup utils Basic utilities
 * @brief simple utilities library
 *
 * This library embeds all the basic utilities manipulated by higher
 * level TREX components. They are all provided by the library named
 * @c lib/libTREXutils
 *
 * @author Frederic Py <fpy@mbari.org>
 * @ingroup core
 */

/** @defgroup domains Domains
 * @brief generic constrained variables 
 *
 * This library embeds all the basic utilities to defined constrained
 * variables used for defining TREX goals and observations. All of these
 * are provided by the library  @c lib/libTREXdomain
 *
 * @author Frederic Py <fpy@mbari.org>
 * @ingroup core
 */

/** @defgroup transaction TREX transaction 
 * @brief TREX reactors and messaging types
 *
 * This module offers all the utilities to help define and implements
 * new reactors. It also defines goals and observations excahnged
 * between reactor as the abstract definition of a clock. All of these
 * are provided by the library  @c lib/libTREXteransaction.
 *
 * Usually plug-ins are based on this library and can then defines new
 * reactors, observations, goals or clocks.
 *
 * @author Conor McGann @& Frederic Py <fpy@mbari.org>
 * @ingroup core
 */
