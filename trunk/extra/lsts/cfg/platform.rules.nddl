#include "declarations.nddl"
#include "platform.nddl"
#include "navigator.nddl"
#include "estimator.nddl"

VehicleState::Boot {
  contained_by(VehicleCommand.Idle);
}

VehicleCommand::Idle {
    // helps the planner remember its controller 
    // is idling
    contained_by(ManeuverController.Idle);
}

//VehicleCommand::Maneuver {

//if (depth > 0) {
//	contained_by(SurfaceController.Underwater);	
//}
//else {
//	contained_by(SurfaceController.Surface);
//}
//}


TrexSupervision::Active {
  vehicle == object.vehicle;
}

Gps::Valid {
  contained_by(SurfaceController.Surface);
}

Gps::Invalid {
  contained_by(SurfaceController.Underwater);
}


// rule that enables the maneuver dispatch

ManeuverController::Idle {
  met_by(Maneuver);
}

ManeuverController::Maneuver {
  starts_during(OperationalLimits.Limits lim);
  depth <= lim.maxDepth;
  lim.minDepth <= depth;
  speed <= lim.maxSpeed;
  lim.minSpeed <= speed;
    
  starts_during(TrexSupervision.Active free);
  VehicleCommand cmd;
  cmd == free.vehicle;
  // met_by(VehicleState.Ready ready);
  met_by(Idle idle);
  // Need this to avoid aggressive archiving
  //ready contained_by idle;
  int min_start;
  min_start <= start;
  if (depth > 0) {
    //met_by(Idle idle);
    if(idle.start <= AGENT_CLOCK ) {      
      ends_before(SurfaceController.Underwater under);
      min_start == under.earliest_start;
      duration <= under.speriod;
      under.requested == true;
      end <= under.latest_end;
    }
  }

  int earliest_start;
    
  earliest_start == max(free.start, idle.start, min_start);

  // Wait free to be started so we do not spam 
  // Platform when Blocked 
  if( earliest_start <= AGENT_CLOCK ) {
		
    equals(cmd.Maneuver request);
		
    request.latitude == lat_rad;
    request.longitude == lon_rad;
    request.depth == depth;
    request.speed == speed;
    request.secs == secs;

  }

  float min_tolerance;
  if (secs == 0)
    min_tolerance <= speed*6.0;
  else if (depth > 0)
    min_tolerance == 20.0;
  else
    min_tolerance == 15.0;
    	
  tolerance == max(min_tolerance, requested_tolerance);
    
  meets(EstimatedState.Position pos);
  distance == ll_distance(lat_rad, lon_rad, pos.latitude, pos.longitude);
  distance <= tolerance;
	

	
}
