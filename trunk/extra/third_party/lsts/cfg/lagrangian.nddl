class LagrangianSpace extends AgentTimeline {
    predicate Holds {
	float origin_lat, origin_lon;
	float cos_angle, sin_angle;
	float speed, _speed_2;
	bool dynamic;
	
	// _speed_2 == speed^2
	speed == sqrt(_speed_2); 
	// 1.0 == cos_angle^2 + sin_angle^2
	calcDistance(1.0, 0.0, 0.0, cos_angle, sin_angle);
    }
    LagrangianSpace(Mode _mode) {
	super(_mode, "Holds");
    }
}

class LagrangianPath extends AgentTimeline {
    predicate Inactive {}

    action ExecutePath {
	PathList path;
	float x, y;
	float factor_x, factor_y;
	bool first;
	
	// Cannot have an empty path
	is_nil(false, path); 
    }
    
    LagrangianPath(Mode _mode) {
	super(_mode, "Inactive");
    }
}

LagrangianPath::ExecutePath {
    PathList        pred;
    LagrangianPoint loc;

    cdr(pred, path);
    car(loc, path);

    x == loc.x*factor_x;
    y == loc.y*factor_y;
    
    first == nil(pred);

    contained_by(condition LagrangianSpace.Holds space);
    contained_by(condition VerticalControl.Holds vc);

    if( true==first ) {
	// This is the first waypoint ... need to do something
    } else {
	met_by(condition ExecutePath prev);
	space contains prev;
	vc contains prev;

	prev.path == pred;
	prev.factor_x == factor_x;
	prev.factor_y == factor_y;
    }
}