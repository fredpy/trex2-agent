#include "navigator.nddl"
#include "estimator.nddl"
#include "platform.nddl"

class NavigationState extends AgentTimeline {
    predicate At {
	float lat, lon;
	float depth;
	bool  requested;
    }
    predicate Moving {
	float target_lat;
	float target_lon;
	float depth;
    }

    NavigationState(Mode _mode) {
	super(_mode, false);
    }
    
}

class SurveyController extends AgentTimeline {
    predicate Active {}
    predicate Transect{
	float lat_from, lon_from;
	float lat_to, lon_to;
	float depth;
    }	    
    SurveyController(Mode _mode) {
	super(_mode, true);
    }
}

class Actions {
    predicate Go {}

    Actions() {
	super();
    }
}


SurveyController::Transect {
    starts(NavigationState.At dest);
    dest.lat == lat_to;
    dest.lon == lon_to;
    dest.depth == depth;
    dest.requested == true;
    
    met_by(Active survey);
    met_by(NavigationState.Moving go);
    go.target_lat == dest.lat;
    go.target_lon == dest.lon;
    go.depth == dest.depth;
    
    after(NavigationState.At src);
    src meets survey;
    src.lat == lat_from;
    src.lon == lon_from;
    src.depth == depth;
    src.requested == true;

    // estimate a minimum duration
    float distance, speed;
    int estimated_duration;
    // hard coded for now ... I need a way to request a speed !!!
    speed >= 0.5;
    speed <= 3.0;
    distance == ll_distance(to_rad(lat_from), to_rad(lon_from), 
			    to_rad(lat_to), to_rad(lon_to));
    estimated_duration == floor(distance * speed * TICK_DURATION);
    if( distance>30 ) {
	survey.duration >= estimated_duration;
    }

}

NavigationState::At {
    if( requested==true ) {
	met_by(Actions.Go);
    }
}

Actions::Go {
    // high level plan
    meets(NavigationState.At requester);
    contained_by(NavigationState.Moving my_go);
    eq(my_go.target_lat, requester.lat);
    eq(my_go.target_lon, requester.lon);
    eq(my_go.depth, requester.depth);

    met_by(Navigator.Idle idle);
    if( idle.start <= AGENT_CLOCK ) {
	meets(Estimator.At requested);
	requested.tolerance <= 10.0;

	equals(Navigator.Going go);
	go.latitude == requested.latitude;
	go.longitude == requested.longitude;
	go.depth == requested.depth;
    }
}

//Estimator::Boot {
//    ends(NavigationState.undefined);
//}

Estimator::At {
    contained_by(NavigationState.At pos);
    lat_deg == pos.lat;
    lon_deg == pos.lon;
    depth == pos.depth;
}

Navigator::Staying {
    contained_by(NavigationState.At pos);
    latitude == to_rad(pos.lat);
    longitude == to_rad(pos.lon);
    depth == pos.depth;
}

Navigator::Going {
    contained_by(NavigationState.Moving go);
    latitude == to_rad(go.target_lat);
    longitude == to_rad(go.target_lon);
    depth == go.depth;
}


NavigationState nav = new NavigationState(Internal);
SurveyController surveys = new SurveyController(Internal);

Actions actions = new Actions();

Navigator navigator = new Navigator(Observe);
Estimator estimator = new  Estimator(External);
// OperationalLimits oplimits = new OperationalLimits(Observe);
// EstimatedState estate = new EstimatedState(Observe);

close();

// rejectable(surveys.Transect transect);
// transect.lat_from.specify(41.185279);
// transect.lon_from.specify(-8.705758);
// transect.lat_to.specify(41.185379);
// transect.lon_to.specify(-8.705758);
// transect.depth.specify(0);




