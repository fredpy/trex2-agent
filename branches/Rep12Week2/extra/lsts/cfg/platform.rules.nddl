#include "declarations.nddl"
#include "platform.nddl"
#include "navigator.nddl"
#include "estimator.nddl"

VehicleState::Boot {
	contained_by(VehicleCommand.Idle);
}


VehicleCommand::Maneuver {

	if (depth > 0) {
		contained_by(SurfaceController.Underwater);	
	}
	else {
		contained_by(SurfaceController.Surface);
	}
}

/*
 * superfluous now :
 *
 * It is all checked by our controller ... as long as nobody uses 
 * VheicleCommand directly we do not need these extra rules
 */ 
// VehicleState::Exec {
// 	contains(VehicleCommand.Maneuver);
// 	met_by(VehicleState.Ready); 
// }

// VehicleCommand::Maneuver {
	
//     met_by(VehicleState.Ready); 
   	
// 	contained_by (OperationalLimits.Limits limits);
//     depth 	<= 	limits.maxDepth;
//     depth 	>= 	limits.minDepth;
//     speed 	<= 	limits.maxSpeed;
//     speed 	>= 	limits.minSpeed;
    
//     // sane == sane_pos(latitude, longitude, depth);
//     // sane == true;
// }
/*
 * end of superfuous
 */

TrexSupervision::Active {
    vehicle == object.vehicle;
}

// rule that enables the maneuver dispatch

ManeuverController::Idle {
	met_by(Maneuver);
}

ManeuverController::Maneuver {
    starts_during(OperationalLimits.Limits lim);
    depth <= lim.maxDepth;
    lim.minDepth <= depth;
    speed <= lim.maxSpeed;
    lim.minSpeed <= speed;
    
    starts_during(TrexSupervision.Active free);
    VehicleCommand cmd;
    cmd == free.vehicle;
    // met_by(VehicleState.Ready ready);
    met_by(Idle idle);
    //ready contained_by idle;
	if (depth > 0) {
		//met_by(Idle idle);
		if(idle.start <= AGENT_CLOCK ) {
		  contained_by(SurfaceController.Underwater under);
		  under.requested == true;
		}
	}

    int earliest_start;
    
    earliest_start == max(free.start, idle.start);

    // Wait free to be started so we do not spam 
    // Platform when Blocked 
    if( earliest_start <= AGENT_CLOCK ) {
		
		equals(cmd.Maneuver request);
		request.latitude == lat_rad;
		request.longitude == lon_rad;
		request.depth == depth;
		request.speed == speed;
		request.secs == secs;

    }

    float min_tolerance;
    if (secs == 0)
    	min_tolerance <= speed*6.0;
    else if (depth > 0)
    	min_tolerance == 20.0;
    else
    	min_tolerance == 15.0;
    	
    tolerance == max(min_tolerance, requested_tolerance);
    
    meets(EstimatedState.Position pos);
	distance == ll_distance(lat_rad, lon_rad, pos.latitude, pos.longitude);
	distance <= tolerance;
	

	
}
