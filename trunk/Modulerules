# -*- jam -*-

if ! $(ModuleRules_INCLUDED) {
  ModuleRules_INCLUDED = TRUE ;
  
  # LIBRARIES in { STATIC , SHARED , NONE }
  LIBRARIES ?= SHARED ;

  rule ModuleVars {
    local name = $(1:G=module) ;
    local vars = $(2:G=var) ;

    Depends $(name) : $(vars) ;
    ROOT_DEPS on $(name) += $(vars) ;
  }

  rule FCheckVar {
    Depends $(1) : $(2) ;
    NotFile $(2) ;
  }

  actions quietly FCheckVar {
    [ $($(2:G=)) ] || ( Echo Variable $(2:G=) is not defined ; exit 1 ) ;
  }

  # Module <name> : <modules this module depends on> ;
  rule Module {
    local name = $(1) ;
    local deps = $(2) ;
    
    local module = $(name:G=module) ;
    local modules = $(deps:G=module) ;

#    Echo $(module) . $(modules) ;
    NotFile $(module) ;
    
    KIND on $(module) = lib ;
    LINK_LIBRARIES on $(module) += $(NEEDSHARES) ;
    EXT_LIBRARIES on $(module) += $(NEEDLIBS) ;
    LINK_MODULES on $(module) += $(modules) ;
    LOCATE_OBJECTS on $(module) += [ FDirName $(SUBDIR) objects ] ;
    LOCATE_SHARED on $(module) += [ FDirName $($(_top)) lib ] ;
    local inc = [ on $(module) return $(INCLUDES) ] ;
    inc = [ FMergeList $(inc) $(SUBDIR) ] ;
    # inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) base ] ] ;
    # inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) component ] ] ;
    INCLUDES on $(module) = $(inc) ;
  }

  rule ModulePlugin {
    local name = $(1) ;
    local deps = $(2) ;
    
    local module = $(name:G=module) ;
    local modules = $(deps:G=module) ;

#    Echo $(module) . $(modules) ;
    NotFile $(name) ;
    Depends $(name) : $(module) ;
    NotFile $(module) ;
        
    KIND on $(module) = plugin ;
    LINK_LIBRARIES on $(module) += $(NEEDSHARES) ;
    EXT_LIBRARIES on $(module) += $(NEEDLIBS) ; 
    LINK_MODULES on $(module) += $(modules) ;
    LOCATE_OBJECTS on $(module) += [ FDirName $(SUBDIR) objects ] ;
    LOCATE_SHARED on $(module) += [ FDirName $($(_top)) lib ] ;
    local inc = [ on $(module) return $(INCLUDES) ] ;
    inc = [ FMergeList $(inc) $(SUBDIR) ] ;
    # inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) base ] ] ;
    # inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) component ] ] ;
    INCLUDES on $(module) = $(inc) ;
  }

  rule ModuleC++Flags {
    local name = $(1) ;
    local fl = $(2) ;
    local module = $(name:G=module) ;

    local flags = [ on $(module) return $(C++FLAGS) ] ;
    flags = [ FMergeList $(flags) $(fl) ] ;
    C++FLAGS on $(module) = $(flags) ;
  }

  rule ModuleMain {
    local name = $(1) ;
    local files = $(2) ;
    local modules = $(3) ;
    
    Depends exe : $(name:G=main) ;
    Clean clean : $(name) ;
    NotFile $(name:G=main) ;
    Depends $(name:G=main) : $(name) ;
    MakeLocate $(name) : [ FDirName $($(_top)) bin ] ;

    local need_shares ;
    local shared_dirs ;
    for link in [ FLinkModules $(modules) ] {
      Depends $(name) : [ FModuleSharedLibraryName $(link) ] ;
      need_shares += $(PROJECT)$(link:G=) ;
      need_shares = [ FMergeList $(need_shares) : [ on $(link:G=module) return $(LINK_LIBRARIES) ] ] ;
      local locate_shared = [ on $(link:G=module) return $(LOCATE_SHARED) ] ;
      shared_dirs = [ FMergeList $(shared_dirs) : $(locate_shared) ] ;
    }
    for shared_dir in $(shared_dirs) {
      LINKFLAGS on $(name) += $(LINKER_PASSTHROUGH_FLAG)$(LIBRARY_PATH_SEARCH_FLAG)$(shared_dir) ;
    }
    NEEDSHARES on $(name) = $(need_shares) ;
    local NEEDLIBS = [ on $(name) return $(EXT_LIBRARIES) ] ; 
    
    local LOCATE_TARGET = [ FDirName $(SUBDIR) objects ] ;
    ModuleObjects $(files) : $(modules) ;
    local outputs ;
    for file in $(files) {
      file = [ FGristFiles $(file) ] ;
      local output = $(file:S=)$(SUFOBJ) ;
      outputs += $(output) ;
    }
    Depends $(name) : $(outputs) ;
    Link $(name) : $(outputs) ;
  }



  rule ModuleIncludes {
    local name = $(1) ;
    local incl = $(2) ;
    local module = $(name:G=module) ;
    
    local inc = [ on $(module) return $(INCLUDES) ] ;
    inc = [ FMergeList $(inc) [ FDirName $(incl) ] ] ;
    INCLUDES on $(module) = $(inc) ;
  }

  rule ModuleFiles {
    local name = $(1) ;
    local files = $(2) ;
    
    local module = $(name:G=module) ;
    local inc = [ on $(module) return $(INCLUDES) ] ;
    inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) ] ] ;
    inc = [ FMergeList $(inc) [ FDirName $(SUBDIR) bits ] ] ;
    INCLUDES on $(module) = $(inc) ;
    
    ModulePart $(module) : $(files) ;
  }

  rule ModuleLibraries {
    local name = $(1) ;
    local libraries = $(2) ;
    local path = $(3) ;
    local module = $(name:G=module) ;
    LINK_LIBRARIES on $(module) = [ FMergeList [ on $(module) return $(LINK_LIBRARIES) ] : $(libraries) ] ;
    LOCATE_SHARED on $(module) += [ FDirName $(path) ] ;
  }

  rule ModuleStatic {
    local name = $(1) ;
    local library = $(2) ;
    local module = $(name:G=module) ;
    
    EXT_LIBRARIES on $(module) = [ FMergeList [ on $(module) return $(EXT_LIBRARIES) ] : $(library) ] ;
  }

  rule ModuleObjects {
    local files = $(1) ;
    local modules = $(2) ;
    local deps = $(3) ;
    
    local links = [ FLinkModules $(modules) ] ;
    local flags = [ on $(module) return $(C++FLAGS) ] ;
    local link ;
    local headers ; 
    for link in $(links) {
      local module = $(link:G=module) ; 
      headers += [ on $(module) return $(INCLUDES) ] ;
    }
    for file in $(files) {
      if $(file:S) != $(SUFOBJ) {
	file = [ FGristFiles $(file) ] ;
	SEARCH on $(file) = $(SEARCH_SOURCE) ; 
	local output = $(file:S=)$(SUFOBJ) ;
	local HDRS = $(headers) ;
	ObjectHdrs $(output) : $(headers) ;
	for dep in $(deps) {
	  FCheckVar $(output) : $(dep) ;
	}
	Object $(output) : $(file) ;
	ObjectC++Flags $(file) : $(flags) $(POSITION_INDEPENDENT_CODE_FLAG) ;
      }
    }
  }

  # internal rules

  rule FMergeList {
    local list1 = $(1) ;
    local list2 = $(2) ;
    
    local result = $(list1) ;
    local i ;
    for i in $(list2) {
      if ! $(i) in $(result) {
	result += $(i) ;
      }
    }
    return $(result) ;
  }

  rule FLinkModules {
    local module = $(1) ;
    
    local pushed ;
    local modules = $(module:G=) ;
    local found ;
    while $(modules) {
      local mod = $(modules[1]) ;
      if $(mod) in $(found) && $(LIBRARIES) = NONE {
	modules = $(modules[2-]) ;
      } else {
	if $(mod) in $(found) {
	  found = [ FRemoveItem $(found) : $(mod) ] ;
	  if ! $(mod) in $(pushed) {
	    pushed += $(mod) ;
	  }
	}
	found += $(mod) ;
	modules = [ FMergeList $(modules[2-]) : [ on $(mod:G=module) return $(LINK_MODULES:G=) ] ] ;
	if $(found) in $(pushed) {
	  Exit Cycle Detected in FLinkModule. ;
	}
      }
    }
    
    return $(found) ;
  }

  rule FModuleStaticLibraryName {
    local module = $(1) ;
    local name = $(module:G=) ;
    return lib$(BASENAME)_$(name)$(SUFLIB) ;
  }

  rule ModuleSharedLibraryFromObjects {
    local name = $(1) ; 
    local files = [ FGristFiles $(2) ] ;
    local kind = $(3) ;
    if ! $(name:D) {
      MakeLocate $(name) $(name)($(files:BS)) : $(LOCATE_TARGET) ;
    }

#    Echo $(name) . $(files:G=) ;

    if $(kind) = lib {
      Depends lib : $(name) ;
    } else {
      NotFile $(kind)s ;
      Depends $(kind)s : $(name) ;
    }
    Depends $(name) : $(files) ;
    Clean clean : $(name) ;
    SharedArchive $(name) : $(files) ; 
  }
  
  actions together Link bind NEEDLIBS
  {
    [ $(NEEDLIBS) ] && NEEDLIBS=\"$(STATIC_FLAG) $(NEEDLIBS) $(END_STATIC)\"
    $(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) -l$(NEEDSHARES) $(NEEDLIBS)
  }

  actions together SharedArchive bind NEEDLIBS {
    [ $(NEEDLIBS) ] && NEEDLIBS = \"$(STATIC_FLAG) $(NEEDLIBS) $(END_STATIC)\"
    $(LINK) $(LINKFLAGS) $(SHARED_FLAG) -o $(1) $(UNDEFS) $(2) $(LINKLIBS) -l$(NEEDSHARES) $(NEEDLIBS)
  }

  rule FModuleSharedLibraryName {
    local module = $(1) ;
    local name = $(module:G=) ;
    return lib$(PROJECT)$(name)$(SUFSHARE) ;
  }

  rule ModuleCfg {
    local name = $(1:G=) ;
    local files = $(2) ;
    local kind = [ on $(name:G=module) return $(KIND) ] ;

    local dest ;
    if $(kind) = lib {
       dest = $($(_top))  ;
    } else {
       dest = [ FDirName $($(_top)) plugin ] ;
    }
 
    MakeLocate $(name) $(files:D=) : [ FDirName $(dest) cfg ] ;
    Depends $(name) : $(files:D=) ;
    Clean clean : $(files:D=) ;
    for f in $(files) {
      File $(f:D=) : $(f) ;
    }
  }

  rule ModulePart {
    local module = $(1) ;
    local files = $(2) ;
    
    local LOCATE_TARGET = [ on $(module) return $(LOCATE_OBJECTS) ] ;
    ModuleObjects $(files) : $(module) : [ on $(module) return $(ROOT_DEPS) ] ;
    
    local library ; 
    for library in $(LIBRARIES) {
      local outputs ;
      local file ;
      for file in $(files) {
	file = [ FGristFiles $(file) ] ;
	local output = $(file:S=)$(SUFOBJ) ;
	outputs += $(output) ;
      }
      local libname ; 
      if $(library) = SHARED {
	local kind = [ on $(module) return $(KIND) ] ;
	libname = [ FModuleSharedLibraryName $(module) ] ;
	local LOCATE_TARGET = [ FDirName $($(_top)) $(kind) ] ;
	LINKFLAGS on $(libname) = $(LINKFLAGS) 
	                          $(LINKER_PASSTHROUGH_FLAG)$(LIBRARY_PATH_SEARCH_FLAG)$(LOCATE_TARGET) ;	
	LINKLIBS on $(libname) = $(LINKLIBS) ;
	local need_shares = [ on $(module) return $(LINK_LIBRARIES) ] ;
	local shared_dirs = [ on $(module) return $(LOCATE_SHARED) ] ;
	local link ;
	for link in [ FLinkModules [ on $(module) return $(LINK_MODULES) ] ] {
	  Depends $(libname) : [ FModuleSharedLibraryName $(link) ] ;
	  need_shares += $(PROJECT)$(link:G=) ;
          need_shares = [ FMergeList $(need_shares) : [ on $(link:G=module) return $(LINK_LIBRARIES) ] ] ;
	  local locate_shared = [ on $(link:G=module) return $(LOCATE_SHARED) ] ;
	  shared_dirs = [ FMergeList $(shared_dirs) : $(locate_shared) ] ;
	}
	for shared_dir in $(shared_dirs) {
	  LINKFLAGS on $(libname) += $(LINKER_PASSTHROUGH_FLAG)$(LIBRARY_PATH_SEARCH_FLAG)$(shared_dir) ;
	}
	NEEDSHARES on $(libname) = $(need_shares) ;
	NEEDLIBS on $(libname) = [ on $(module) return $(EXT_LIBRARIES) ] ;
# 	Echo $(libname) . [ on $(libname) return $(NEEDLIBS) ] ;
	ModuleSharedLibraryFromObjects $(libname) : $(outputs) : $(kind) ;	
      } else if $(library) = STATIC {
	libname = [ FModuleStaticLibraryName $(module) ] ;
	LINKFLAGS on $(libname) = $(LINKFLAGS) 
	                          $(LINKER_PASSTHROUGH_FLAG)$(LIBRARY_PATH_SEARCH_FLAG)$(LOCATE_TARGET) ;
	LINKLIBS on $(libname) = $(LINKLIBS) ;
	NEEDLIBS on $(libname) = [ on $(module) return $(EXT_LIBRARIES) ] ;
	ModuleStaticLibraryFromObjects $(libname) : $(outputs) ;
      } else {
	Exit ModulePart unknown library type : $(library) ;
      }
      Depends $(module) : $(libname) ;
#      Echo $(module) . $(libname) ;
    }
  }

} # ModuleRules_INCLUDED