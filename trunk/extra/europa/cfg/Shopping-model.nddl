#include "TREX.nddl"

// Classes for Locations (Home, SuperMarket, etc.), Products (Banana, etc.) and
// ProductLocations (Banana can be found at SuperMarket, for example)
/* 
class Location {
  string name;
  Location(string _name){
    name = _name;
  }
} */

enum Location { Home, SuperMarket, HardwareStore };

/* 
class Product {
  string name;
  Product(string _name) {
    name = _name;
  }
} */

enum Product {Banana, Milk, Drill};

class ProductLocation {
  Location location;
  Product product;

  ProductLocation(Location _location, Product _product){
    location = _location;
    product = _product;
  }
}

// Use built-in Timeline functionality to enforce that an agent:
// a) Can't be at more than one place at a time.
// b) Can't Go more than one place at a time.
// c) Can't Go somewhere and be At somewhere at the same time.
class AgentLocation extends AgentTimeline{

  AgentLocation(Mode _mode){
    super(_mode);
  }

  predicate At {
    Location loc;
  }

  predicate Go {
    Location from;
    Location to;
  }
}

// In addition to a timeline, the agent can buy things.  Note that Buy can
// (must, in fact) be simultaneous with an At token and the Buy predicate
// therefore cannot be defined as part of the AgentTimeline.
class Agent extends AgentTimeline {

  Agent(Mode _mode) {
    super(_mode, true);
  }

  action Go {
    Location from;
    Location to;
  }

  action Buy {
    Product product;
  }

  predicate Own {
    Product product;
  }

}


// Define the rules for AgentLocation

AgentLocation::At {
  met_by(Go prevGo);
  eq(loc, prevGo.to);
  meets(Go nextGo);
  eq(loc, nextGo.from);

}

AgentLocation::Go {
  met_by(At originToken);
  eq(from, originToken.loc);
  meets(At destinationToken);
  eq(to, destinationToken.loc);

}

// Define the rules for Agent

Agent::Go {
  met_by(condition AgentLocation.At origin);
  eq(from, origin.loc);

  equals(condition AgentLocation.Go going);
  eq(going.from, from);
  eq(going.to, to);

  meets(effect AgentLocation.At destination);
  eq(to, destination.loc);

}

Agent::Buy {

  // initialized to all locations
  ProductLocation possibleStores;

  // limit possibleStores variables to ones that provide what we need to buy
  eq(product, possibleStores.product);

  // We must be At a location during our Buy, and that location must have the
  // product we want available:
  contained_by(condition AgentLocation.At currLocation);
  eq(currLocation.loc, possibleStores.location);
  
  meets(effect Own purchase);
  eq(purchase.product,product);

  // A Buy takes 10 time units
  eq(10, duration);
}

Agent::Own {
  eq(1, duration);
}
