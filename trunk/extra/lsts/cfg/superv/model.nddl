#include "navigator.nddl"
#include "estimator.nddl"
#include "platform.nddl"

class NavigationState extends AgentTimeline {
    predicate At {
	float lat, lon;
	float depth;
	bool  requested;
    }
    predicate Moving {
	float target_lat;
	float target_lon;
	float depth;
    }

    NavigationState(Mode _mode) {
	super(_mode, false);
    }   
}

class SurveyController extends AgentTimeline {
    predicate Transit {}
    predicate Surveying {
	float lat_from, lon_from;
	float depth;
    }
    predicate Transect{
	float lat_from, lon_from;
	float lat_to, lon_to;
	float depth;
    }	    
    SurveyController(Mode _mode) {
	super(_mode, true);
    }
}

class Actions extends Timeline {
    predicate Go {}

    Actions() {
	super();
    }
}


// synchronization rules

Estimator::At {
    starts(NavigationState.At pos);
    lat_deg == pos.lat;
    lon_deg == pos.lon;
    depth == pos.depth;
}


Navigator::Staying {
    contained_by(NavigationState.At pos);
    latitude == to_rad(pos.lat);
    longitude == to_rad(pos.lon);
    depth == pos.depth;
}

Navigator::Going {
    ends(NavigationState.Moving go);
    latitude == to_rad(go.target_lat);
    longitude == to_rad(go.target_lon);
    depth == go.depth;
}


NavigationState::At {
    if( requested==true ) {
	met_by(Actions.Go);
    }
}

Actions::Go {
    // high level plan
    meets(NavigationState.At requester);
    contained_by(NavigationState.Moving my_go);
    eq(my_go.target_lat, requester.lat);
    eq(my_go.target_lon, requester.lon);
    eq(my_go.depth, requester.depth);

    // refinement in the actions
    met_by(Navigator.Idle idle);
    if( idle.start <= AGENT_CLOCK ) {
	meets(Estimator.At requested);
	requested.tolerance == 10.0;
	requested.secs == 0;

	equals(Navigator.Going go);
	go.latitude == requested.latitude;
	go.longitude == requested.longitude;
	go.depth == requested.depth;
    }
}

SurveyController::Transit {
    ends(NavigationState.At point);
    contains(NavigationState.Moving go);
    go.target_lat == point.lat;
    go.target_lon == point.lon;
    go.depth == point.depth;
    go meets point;
}

SurveyController::Surveying {
    met_by(Transit);
    met_by(NavigationState.At initial);
    initial.lat == lat_from;
    initial.lon == lon_from;
    initial.depth == depth;
    initial.requested == true;
}

SurveyController::Transect {
    met_by(Surveying survey);
    survey.lat_from == lat_from;
    survey.lon_from == lon_from;
    survey.depth == depth;
    
    float distance, speed, delta_t;
    int estimated_duration;
    distance == ll_distance(to_rad(lat_from), to_rad(lon_from),
			    to_rad(lat_to), to_rad(lon_to));
    // speed >= 0.5;
    // speed <= 6.0;

    // delta_t * speed == distance * TICK_DURATION;
    
    // if( distance>30.0 )
    // 	survey.duration >= floor(delta_t);

    // Later I will have to put the extra details
    starts(NavigationState.At dest);
    dest.lat == lat_to;
    dest.lon == lon_to;
    dest.depth == depth;
    // may need a protection here ...
    dest.requested == true;
    met_by(NavigationState.Moving go);
    // go equals survey;
}


NavigationState nav = new NavigationState(Internal);
SurveyController surveys = new SurveyController(Internal);

Actions actions = new Actions();

Navigator navigator = new Navigator(Observe);
Estimator estimator = new  Estimator(External);
// OperationalLimits oplimits = new OperationalLimits(Observe);
// EstimatedState estate = new EstimatedState(Observe);

close();

// rejectable(surveys.Transect transect);
// transect.lat_from.specify(41.185279);
// transect.lon_from.specify(-8.705758);
// transect.lat_to.specify(41.185379);
// transect.lon_to.specify(-8.705758);
// transect.depth.specify(0);




