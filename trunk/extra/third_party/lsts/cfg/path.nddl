class LagrangianPoint {
    float x, y;

    LagrangianPoint(float _x, float _y) {
	x = _x;
	y = _y;
    }
}

class PathList {
    bool nil;
    LagrangianPoint car;
    PathList cdr;
    
    PathList() {
	nil = true;
    }
    PathList(LagrangianPoint loc, PathList p) {
	nil = false;
	car = loc;
	cdr = p;
    }
    PathList(LagrangianPoint l1, LagrangianPoint l2, PathList p) {
	nil = false;
	car = l1;
	cdr = new LagrangianPoint(l2, p);
    }
    PathList(LagrangianPoint l1, LagrangianPoint l2, 
	     LagrangianPoint l3, PathList p) {
	nil = false;
	car = l1;
	cdr = new LagrangianPoint(l2, l3, p);
    }
    PathList(LagrangianPoint l1, LagrangianPoint l2, 
	     LagrangianPoint l3, LagrangianPoint l4, 
	     PathList p) {
	nil = false;
	car = l1;
	cdr = new LagrangianPoint(l2, l3, l4, p);
    }
    PathList(LagrangianPoint l1, LagrangianPoint l2, 
	     LagrangianPoint l3, LagrangianPoint l4, 
	     LagrangianPoint l5, PathList p) {
	nil = false;
	car = l1;
	cdr = new LagrangianPoint(l2, l3, l4, l5, p);
    }    
    PathList(LagrangianPoint l1, LagrangianPoint l2, 
	     LagrangianPoint l3, LagrangianPoint l4, 
	     LagrangianPoint l5, LagrangianPoint l6,
	     PathList p) {
	nil = false;
	car = l1;
	cdr = new LagrangianPoint(l2, l3, l4, l5, l6, p);
    }
}


// TODO : migarte these constraints to europa extensions for lsts
constraint cdr(a, b) { a <: PathList && b <: PathList }
constraint car(a, b) { a <: PathList && b <: LagrangianPoint }
constraint isNil(a, ret) { a <: PathList && ret <: bool }

PathList nilPath = new PathList(); // special value for the end of the path

class VerticalControl extends AgentTimeline {
    predicate Holds {
	float speed, horizontal_speed, _hspeed_2;
	float min_z, max_z;
	float pitch_angle, _corrected_pitch;
	
	0.0 < speed;
	0.0 <= _corrected_pitch;
	_corrected_pitch <= pitch_angle;
	min_z <= max_z;
	horizontal_speed == sqrt(_hspeed_2);
    }
    
    VerticalControl(Mode _mode) {
	super(_mode, "Holds");
    }
}

class LagrangianSpace extends AgentTimeline {
    predicate Holds {
	float origin_lat, origin_lon;
	float cos_angle, sin_angle;
	float speed, _speed_2;
	bool dynamic;
	
	speed == sqrt(_speed_2); 
	calcDistance(1.0, 0.0, 0.0, cos_angle, sin_angle);
    }
    LagrangianSpace(Mode _mode) {
	super(_mode, "Holds");
    }
}

class LagrangianPath extends AgentTimeline {
    predicate Inactive {}

    action ExecutePath {
	PathList path;
	float x, y;
	float factor_x, factor_y;
	float drift;
	bool first;

	isNil(path, false);
    }

    LagrangianPath(Mode _mode) {
	super(_mode, "Inactive");
    }
}

VerticalControl::Holds {
    met_by(Holds prev);
    
    // How can I set the pitch_angle properly ?
    pitch_angle == 0.5; // 0.5 rad ~ 30 degrees
    
    if( min_z==max_z ) {
	_corrected_pitch == 0;
    } else {
	_corrected_pitch == pitch_angle;
    }
    horizontal_speed == speed * cos(_corrected_pitch);
}

LagrangianPath::ExecutePath {
    PathList        pred;
    LagrangianPoint loc;

    cdr(path, pred);
    car(path, point);
    isNil(pred, first);

    contained_by(condition LagrangianSpace.Holds space);
    contained_by(condition VerticalControl.Holds vc);
    
    if( first==true ) {
	// This is the firtst waypoint
    } else {
	met_by(condition ExecutePath prev);
	space contains prev;
	vc contains prev;
	prev.path == pred;
	prev.factor_x == factor_x;
	prev.factor_y == factor_y;
	
    }
}