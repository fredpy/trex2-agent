#include "declarations.nddl"
#include "platform.nddl"
#include "navigator.nddl"
#include "estimator.nddl"

VehicleState::Boot {
	contained_by(VehicleCommand.Idle);
}

/*
 * superfluous now :
 *
 * It is all checked by our controller ... as long as nobody uses 
 * VheicleCommand directly we do not need these extra rules
 */ 
// VehicleState::Exec {
// 	contains(VehicleCommand.Maneuver);
// 	met_by(VehicleState.Ready); 
// }

// VehicleCommand::Maneuver {
	
//     met_by(VehicleState.Ready); 
   	
// 	contained_by (OperationalLimits.Limits limits);
//     depth 	<= 	limits.maxDepth;
//     depth 	>= 	limits.minDepth;
//     speed 	<= 	limits.maxSpeed;
//     speed 	>= 	limits.minSpeed;
    
//     // sane == sane_pos(latitude, longitude, depth);
//     // sane == true;
// }
/*
 * end of superfuous
 */

TrexSupervision::Active {
    vehicle == object.vehicle;
}

// rule that enables the maneuver dispatch

ManeuverController::Maneuver {
    starts_during(OperationalLimits.Limits lim);
    depth <= lim.maxDepth;
    lim.minDepth <= depth;
    speed <= lim.maxSpeed;
    lim.maxSpeed <= speed;

    starts_during(TrexSupervision.Active free);
    VehicleCommand cmd;
    cmd == free.vehicle;
    met_by(VehicleState.Ready ready);
    contained_by(VehicleState.Exec);    
    
    int earliest_start;
    
    earliest_start == max(free.start, ready.start);

    // Wait free to be started so we do not spam 
    // Platform when Blocked 
    // Apparently the commands doers not goes though 
    // if I am not ready (?!!)
    if( earliest_start <= AGENT_CLOCK ) {
	
	equals(cmd.Maneuver request);
	request.latitude == lat_rad;
	request.longitude == lon_rad;
	request.depth == depth;
	request.speed == speed;
	request.secs == secs;

    }

    tolerance <= 10.0; // hard coded to 10. m for now 

    if( end <= AGENT_CLOCK ) {
	meets(EstimatedState.Position pos);
	ll_distance(lat_rad, lon_rad, pos.latitude, pos.longitude) <= tolerance;
	// if it fails replanning should be able to correct it
    }
}