class DrifterFollow;

class DrifterController {
    DrifterFollow command;

    action EndSurvey {}

    action DoSegment {}

    action DoInitial {}

    predicate Waypoint {
	int             path_id;
	PathList        full_path, completed, to_complete;
	LagrangianPoint loc;
	
	float           ref_lat, ref_lon;
	float           shift_x, shift_y;
	float           cos_a, sin_a;
	float           lat, lon;

	int completion_date;

	car(loc,         completed);
	cdr(to_complete, completed);
	duration == 1;
	completion_date <= start;
    }

    DrifterController(DrifterFollow cmd) {
	command = cmd;
    }
}

class Counter extends Timeline {

    predicate Holds {
	int id;
	0 <= id;
	id <= start;
    }

    Counter() {}
}

class DrifterFollow extends AgentTimeline {
    DrifterController controller;
    Counter           counter;

    predicate Inactive {}

    predicate DoSurvey {
	float center_lat, center_lon;
	float speed, _speed_2;
	float cos_angle, sin_angle;

	PathList path;
	float    size;
	bool     lagrangian;

	int id;
    }
    predicate Survey {
	float    center_lat, center_lon;
	float    speed_north, speed_east, u, v;
	PathList path;
	float    size;
	bool     lagrangian;

	speed_east  == v;
	speed_north == u;

	duration==1;
    }

    DrifterFollow(Mode _mode) {
	super(_mode, "Inactive");
	controller = new DrifterController(this);
	counter = new Counter();
    }
}

Counter::Holds {
    if( start<=0 ) {
	id == 0;
    } else {
	met_by(Holds prev);
	id == prev.id + 1;
    }
}

DrifterFollow::Inactive {
    Counter cpt = object.counter;
    starts(cpt.Holds cur);
}

DrifterFollow::DoSurvey {
    Counter cpt = object.counter;
    contained_by(cpt.Holds cur);
    id == cur.id;
}

DrifterController::EndSurvey {
    DrifterFollow me = object.command;
    Counter cpt = me.counter;

    equals(effect me.Survey survey);
    float _bind_u_2, _bind_v_2;
    
    abs(survey.u) == sqrt(_bind_u_2);
    abs(survey.v) == sqrt(_bind_v_2);


    ends(cpt.Holds cur);
    met_by(me.DoSurvey exec);
    exec.id == cur.id;
    exec.path == survey.path;
    exec.size == survey.size;
    exec.center_lat == survey.center_lat;
    exec.center_lon == survey.center_lon;
    exec.lagrangian == survey.lagrangian;
    exec._speed_2 == _bind_u_2+_bind_v_2;
    exec.speed == sqrt(exec._speed_2);
   
    contained_by(VerticalControl.Holds vc);
    vc contains exec;
    _bind_u_2 < vc._hspeed_2;
    _bind_v_2 < vc._hspeed_2;

    if( 0==exec.speed ) {
	exec.cos_angle == 1.0;
	exec.sin_angle == 0.0;
    } else {
	exec.cos_angle * exec.speed == survey.speed_north;
	exec.sin_angle * exec.speed == survey.speed_east;
    }

    equals(condition Waypoint last_wp);
    last_wp.path_id == cur.id;
    last_wp.full_path == exec.path;
    last_wp.completed == exec.path;
    exec.cos_angle == last_wp.cos_a;
    exec.sin_angle == last_wp.sin_a;
}

DrifterController::Waypoint {
    DrifterFollow me = object.command;
    Counter cpt = me.counter;
    contained_by(cpt.Holds count);
    path_id == count.id;

    float shift_n, shift_e;
    shift_e == (shift_x * cos_a) + (shift_y * sin_a);
    shift_n == (shift_y * cos_a) - (shift_x * sin_a);
    
    wgsdisplace(ref_lat, ref_lon, shift_n, shift_e, lat, lon);
}

DrifterController::DoSegment {
    DrifterFollow me = object.command;
    Counter cpt = me.counter;
    
    meets(effect Waypoint to);
    false == empty(to.to_complete);

    contained_by(me.DoSurvey exec);
    exec.id == to.path_id;
    exec.path == to.full_path;
    exec.cos_angle == to.cos_a;
    exec.sin_angle == to.sin_a;
    contained_by(VerticalControl.Holds vc);
    vc contains exec;
    
    starts(condition Waypoint from);
    from.path_id == to.path_id;
    from.full_path == to.full_path;
    from.completed == to.to_complete;
    from.lat == to.ref_lat;
    from.lon == to.ref_lon;
    from.completion_date <= to.completion_date;
    exec.cos_angle == from.cos_a;
    exec.sin_angle == from.sin_a;

    float dx, dy, delta_y;
    
    from.loc.x + dx == to.loc.x; 
    to.shift_x == dx * exec.size;
    from.loc.y + dy == to.loc.y; 
    delta_y == dy * exec.size;

    float drift;
    drift >= 0.0;
    to.shift_y == delta_y + drift;

    if( exec.lagrangian==false ) {
	drift == 0.0;
    } else {

	float dspeed_2, px_2, py_2;
	
	dspeed_2 == exec._speed_2 + vc._hspeed_2;
	abs(to.shift_x) == sqrt(px_2);
	abs(delta_y) == sqrt(py_2);
	
	float vx_2, vy_2, sq_root, upper_frac, vy, main_sum;
	vx_2 == vc._hspeed_2 * px_2;
	vy_2 == vc._hspeed_2 * py_2;

	vy == exec.speed * delta_y;
	main_sum == sqrt(vx_2 + vy_2) + vy;
	drift * dspeed_2 == exec.speed * main_sum;
    }

    // Finally send the next At when the previous one did complete
    if( from.completion_date <= AGENT_CLOCK ) {
	// I will assume that from are to are far enough to require a waypoint
	meets(condition Navigator.At dest);
	dest.latitude == to.lat;
	dest.longitude == to.lon;
	dest.speed == vc.speed;
	dest.secs == 0;
	dest.z == vc.min_z;
	to.completion_date == dest.start;
   }
}

DrifterController::DoInitial {
    DrifterFollow me = object.command;
    Counter cpt = me.counter;

    equals(effect Waypoint to);
    true == empty(to.to_complete);

    contained_by(me.DoSurvey exec);
    exec.id == to.path_id;
    exec.path == to.full_path;
    exec.center_lat == to.ref_lat;
    exec.center_lon == to.ref_lon;
    exec.cos_angle == to.cos_a;
    exec.sin_angle == to.sin_a;
    contained_by(VerticalControl.Holds vc);
    vc contains exec;

    float x, y;

    to.shift_x == to.loc.x * exec.size;
    to.shift_y == to.loc.y * exec.size;

    // Check that I can start 
    contained_by(cpt.Holds cur);
    if( cur.start<= AGENT_CLOCK ) {
	contained_by(condition Navigator.At dest);
	dest.latitude == to.lat;
	dest.longitude == to.lon;
	dest.speed == vc.speed;
	dest.secs == 0;
	dest.z == vc.min_z;
	to.completion_date == dest.start;
    }
}


