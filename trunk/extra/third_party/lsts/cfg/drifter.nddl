class DrifterFollow;

class DrifterController {
    DrifterFollow command;

    action DoSurvey {
	start + duration == end;
    }

    predicate Waypoint {
	PathList completed, target;
	LagrangianPoint loc;
	float origin_lat, origin_lon;
	float delta_x, delta_y;
	float lat, lon, factor;
	bool first;
	bool ready;

	duration == 1;
	start + duration == end;
    }

    action DoSegment {
	PathList to_complete;
	float x, y, drift;
	bool completed;
	start + duration == end;
    }
    action DoInitial {
	float x, y;
	start + duration == end;
    }

    DrifterController(DrifterFollow d) {
	command = d;
    }
}



class DrifterFollow extends AgentTimeline {

    DrifterController controller;

    predicate Inactive {
	start + duration == end;
    }

    predicate DoSurvey {
	bool     lagrangian;
	PathList path;
	float    size;
	start + duration == end;
    }

    predicate Survey {
	float center_lat, center_lon;
	float speed_north, speed_east, u, v;

	PathList path;
	float    size;
	bool     lagrangian;
       
	speed_east == u;
	speed_north == v;
	duration == 1;
	start + duration == end;
    }

    DrifterFollow(Mode _mode) {
	super(_mode, "Inactive");
	controller = new DrifterController(this);
    }
}

DrifterController::DoSurvey {
    DrifterFollow me = object.command;

    meets(effect me.Survey g);
    contained_by(LagrangianSpace.Holds space);
    contained_by(condition VerticalControl.Holds vc);

    float _bind_u_2, _bind_v_2;

    _bind_u_2 < vc._hspeed_2;
    _bind_v_2 < vc._hspeed_2;
    
    abs(g.u) == sqrt(_bind_u_2);
    abs(g.v) == sqrt(_bind_v_2);    
    
    // Set up the lagrangian space
    space._speed_2 == _bind_u_2+_bind_v_2;
    space.origin_lat == g.center_lat;
    space.origin_lon == g.center_lon;

    if( 0.0==space.speed ) {
	space.cos_angle == 1.0;
	space.sin_angle == 0.0;
    } else {
     	space.cos_angle * space.speed == g.u;
     	space.sin_angle * space.speed == g.v;
    }

    equals(me.DoSurvey exec);
    exec meets g;
    space contains exec;
    vc contains exec;

    exec.path == g.path;
    exec.size == g.size;
    exec.lagrangian == g.lagrangian;
	
    before(me.Inactive idle);
    g meets idle;
    
    meets(condition Waypoint full);
    full.completed == g.path; 
    full.target == g.path;
}

DrifterController::Waypoint {
    DrifterFollow me = object.command;
    PathList prev;

    car(loc, completed);
    first == empty(prev);
    
    if( completed==target ) {
	equals(me.Survey completion);
	target == completion.path;
	factor == completion.size;
    } else {
        contained_by(me.DoSurvey exec);
	target == exec.path;
	factor == exec.size;
    }

    contained_by(LagrangianSpace.Holds space);

    // Rotate the points based on space direction
    float rot_x, rot_y;
    rot_x == (delta_x * space.cos_angle) + (delta_y * space.sin_angle);
    rot_y == (delta_y * space.cos_angle) - (delta_x * space.sin_angle);

    // Compute the point lat,lon
    wgsdisplace(origin_lat, origin_lon, rot_x, rot_y, lat, lon);
}

DrifterController::DoSegment {
    DrifterFollow me = object.command;

    meets(effect Waypoint wp);
    contained_by(me.DoSurvey exec);

    x == wp.loc.x * wp.factor;
    y == wp.loc.y * wp.factor;
    false == wp.first;
    wp.ready == completed;
    cdr(to_complete, wp.completed);

    starts(condition Waypoint init);
    init.target == wp.target;
    init.completed == to_complete;
    wp.origin_lat == init.lat;
    wp.origin_lon == init.lon;

    exec contains init;
    if( init.start <= AGENT_CLOCK ) {
	completed == true;
    }

    // Start to make general computation for waypoint 
    contained_by(LagrangianSpace.Holds space);
    contained_by(VerticalControl.Holds vc);

    float delta_y;
    init.loc.x + wp.delta_x == x;
    init.loc.y + delta_y == y;

    float dspeed_2, px_2, py_2;
    dspeed_2 == space._speed_2 + vc._hspeed_2;
    abs(wp.delta_x) == sqrt(px_2);
    abs(delta_y) == sqrt(py_2);

    float vx_2, vy_2, sq_root, upper_frac, vy, main_sum;

    vx_2 == vc._hspeed_2 * px_2;
    vy_2 == vc._hspeed_2 * py_2;

    vy == space.speed * delta_y;
    main_sum == sqrt(vx_2+vy_2) + vy;
    drift * dspeed_2 == space.speed * main_sum;

    float travel_dist;

    wp.delta_y == delta_y+drift;
    calcDistance(travel_dist, 0.0, 0.0, wp.delta_x, wp.delta_y);

    end <= MISSION_END;
    start+duration == end;
    
    float fast_speed, min_duration;

    fast_speed == 3.0*vc.horizontal_speed;
    travel_dist == min_duration * fast_speed;
    min_duration <= duration;

    if( completed==true ) {
	meets(condition Navigator.At cmd);
	cmd.latitude == wp.lat;
	cmd.longitude == wp.lon;
	cmd.z == vc.min_z; // for now navigate at min_z
	cmd.speed == vc.speed;
	cmd.secs == 0;
    }
}

DrifterController::DoInitial {
    meets(effect Waypoint wp);
    x == wp.loc.x * wp.factor;
    y == wp.loc.y * wp.factor;
    true == wp.first;

    // Start to make general computation for waypoint 
    contained_by(LagrangianSpace.Holds space);
    contained_by(VerticalControl.Holds vc);

    wp.origin_lat == space.origin_lat;
    wp.origin_lon == space.origin_lon;
    wp.delta_x == x;
    wp.delta_y == y;

    true == wp.ready;

    meets(condition Navigator.At cmd);
    cmd.latitude == wp.lat;
    cmd.longitude == wp.lon;
    cmd.z == vc.min_z; // for now navigate at min_z
    cmd.speed == vc.speed;
    cmd.secs == 0;
}

	
    




