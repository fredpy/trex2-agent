class DrifterFollow;

class DrifterController {
    DrifterFollow command;

    action DoSurvey {
	start + duration == end;
    }

    predicate Waypoint {
	PathList completed, target;
	LagrangianPoint loc;
	float origin_lat, origin_lon;
	float x, y;
	float delta_x, delta_y;
	float lat, lon, factor;
	bool first;
	int  id;
	bool ready, executed;

	duration == 1;
	start + duration == end;
    }

    action DoSegment {
	PathList to_complete;
	float dx, dy, drift;
	bool completed;
	start + duration == end;
    }
    action DoInitial {
	float x, y;
	start + duration == end;
    }

    DrifterController(DrifterFollow d) {
	command = d;
    }
}

class Counter extends Timeline {
    predicate Holds {
	int id;
	id >= 0;
    }

    Counter() {}
};

Counter::Holds {
    // Assume that initial tick is 0
    if( start > 0 ) {
	met_by(Holds prev);
	id == prev.id + 1;
    } else {
	id == 0;
    }	
}

class DrifterFollow extends AgentTimeline {

    DrifterController controller;
    Counter counter;

    predicate Inactive {
	int _id;
	start + duration == end;
    }

    predicate DoSurvey {
	bool     lagrangian;
	PathList path;
	float    size;
	int      id;
	start >= 0;
	start + duration == end;
    }

    predicate Survey {
	float center_lat, center_lon;
	float speed_north, speed_east, u, v;
	int _id;
	
	PathList path;
	float    size;
	bool     lagrangian;
	start > 0;
	speed_east == u;
	speed_north == v;
	//duration == 1;
	start + duration == end;
    }

    DrifterFollow(Mode _mode) {
	super(_mode, "Inactive");
	controller = new DrifterController(this);
	counter = new Counter();
    }
}


DrifterFollow::Inactive {
    Counter my_id = object.counter;
    starts(my_id.Holds cpt);
    _id == cpt.id;
    end <= cpt.end;
}

DrifterFollow::DoSurvey {
    Counter my_id = object.counter;
    contained_by(my_id.Holds cpt);
    id == cpt.id;
}

DrifterFollow::Survey {
    Counter my_id = object.counter;
    ends(my_id.Holds cpt);
    met_by(DoSurvey exec);
    after(Inactive previous);
    previous starts cpt;
    previous before exec;
    
    _id == cpt.id;
}


DrifterController::DoSurvey {
    DrifterFollow me = object.command;

    meets(effect me.Survey g);
    contained_by(LagrangianSpace.Holds space);
    contained_by(condition VerticalControl.Holds vc);

    float _bind_u_2, _bind_v_2;

    _bind_u_2 < vc._hspeed_2;
    _bind_v_2 < vc._hspeed_2;
    
    abs(g.u) == sqrt(_bind_u_2);
    abs(g.v) == sqrt(_bind_v_2);    
    
    // Set up the lagrangian space
    space._speed_2 == _bind_u_2+_bind_v_2;
    space.origin_lat == g.center_lat;
    space.origin_lon == g.center_lon;

    if( 0.0==space.speed ) {
	space.cos_angle == 1.0;
	space.sin_angle == 0.0;
    } else {
     	space.cos_angle * space.speed == g.u;
     	space.sin_angle * space.speed == g.v;
    }

    equals(me.DoSurvey exec);
    exec.id == g._id;
    exec meets g;
    space contains exec;
    vc contains exec;

    exec.path == g.path;
    exec.size == g.size;
    exec.lagrangian == g.lagrangian;
	
    before(me.Inactive idle);
    g meets idle;
    
    meets(condition Waypoint full);
    full.completed == g.path; 
    full.target == g.path;
}

DrifterController::Waypoint {
    DrifterFollow me = object.command;
    PathList prev;

    car(loc, completed);
    x == loc.x * factor;
    y == loc.y * factor;
    
    first == empty(prev);
    
    if( completed==target ) {
	equals(me.Survey completion);
	target == completion.path;
	factor == completion.size;
	id == completion._id;
    } else {
        contained_by(me.DoSurvey exec);
	target == exec.path;
	factor == exec.size;
	id == exec.id;
    }

    if( ready==true ) {
	contained_by(Navigator.At nav);
	nav.latitude == lat;
	nav.longitude == lon;
	
	if( nav.start <= AGENT_CLOCK ) {
	    executed == true;
	}
    }
	

    contained_by(LagrangianSpace.Holds space);

    // Rotate the points based on space direction
    float rot_x, rot_y;
    rot_x == (delta_x * space.cos_angle) + (delta_y * space.sin_angle);
    rot_y == (delta_y * space.cos_angle) - (delta_x * space.sin_angle);

    // Compute the point lat,lon
    wgsdisplace(origin_lat, origin_lon, rot_x, rot_y, lat, lon);
}

DrifterController::DoSegment {
    DrifterFollow me = object.command;

    meets(effect Waypoint wp);
    contained_by(me.DoSurvey exec);

    false == wp.first;
    wp.ready == completed;
    cdr(to_complete, wp.completed);

    starts(condition Waypoint init);
    init.id == wp.id;
    init.target == wp.target;
    init.completed == to_complete;
    wp.origin_lat == init.lat;
    wp.origin_lon == init.lon;

    init.x + dx == wp.x;
    init.y + dy == wp.y;
    dx == wp.delta_x;

    exec contains init;
    completed == init.executed;

    // Start to make general computation for waypoint 
    contained_by(LagrangianSpace.Holds space);
    contained_by(VerticalControl.Holds vc);

    float dspeed_2, px_2, py_2;
    dspeed_2 == space._speed_2 + vc._hspeed_2;
    abs(dx) == sqrt(px_2);
    abs(dy) == sqrt(py_2);

    float vx_2, vy_2, sq_root, upper_frac, vy, main_sum;

    vx_2 == vc._hspeed_2 * px_2;
    vy_2 == vc._hspeed_2 * py_2;

    vy == space.speed * dy;
    main_sum == sqrt(vx_2+vy_2) + vy;
    drift * dspeed_2 == space.speed * main_sum;

    float travel_dist;

    wp.delta_y == dy+drift;
    calcDistance(travel_dist, 0.0, 0.0, wp.delta_x, wp.delta_y);

    end <= MISSION_END;
    start+duration == end;
    
    float fast_speed, min_duration;

    fast_speed == 3.0*vc.horizontal_speed;
    travel_dist == min_duration * fast_speed;
    min_duration <= duration;

    if( completed==true ) {
	meets(condition Navigator.At cmd);
	cmd.latitude == wp.lat;
	cmd.longitude == wp.lon;
	cmd.z == vc.min_z; // for now navigate at min_z
	cmd.speed == vc.speed;
	cmd.secs == 0;
    }
}

DrifterController::DoInitial {
    Counter my_counter = object.command.counter;

    equals(effect Waypoint wp);
    true == wp.first;

    // Start to make general computation for waypoint 
    contained_by(LagrangianSpace.Holds space);
    contained_by(VerticalControl.Holds vc);

    wp.origin_lat == space.origin_lat;
    wp.origin_lon == space.origin_lon;
    wp.x == x;
    wp.y == y;
    wp.delta_x == x;
    wp.delta_y == y;
    
    contained_by(my_counter.Holds cpt);
    wp.id == cpt.id;
    
    if( cpt.start <= AGENT_CLOCK ) {
	true == wp.ready;

	ends(condition Navigator.At cmd);
	cmd.latitude == wp.lat;
	cmd.longitude == wp.lon;
	cmd.z == vc.min_z; // for now navigate at min_z
	cmd.speed == vc.speed;
	cmd.secs == 0;
    }
}

	
    




